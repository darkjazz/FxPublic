{\rtf1\ansi\ansicpg1252\cocoartf949\cocoasubrtf540
{\fonttbl\f0\fnil\fcharset238 Inconsolata;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red96\green96\blue96;\red0\green115\blue0;
\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs24 \cf0 ~fx = \cf2 FxPublic\cf0 ().makeOglGui;\
\
~fx.startFx;\
\
\
(\
	~fx.addGlobalsResponder;\
	~fx.addStatesResponder;\
	~fx.addTriggerResponder;\
	\
	~buf = \cf2 Buffer\cf0 .read(s, \cf3 "sounds/a11wlk01.wav"\cf0 );\
	\
	\cf2 SynthDef\cf0 (\cf4 \\fxwarp\cf0 , \{\cf2 |out, buf, ptr, frq, wsz, dns, ratio, amp, rev, rtime, gate, azm|\cf0 \
		\cf2 var\cf0  sig, env, rL, rR;\
		env = \cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 ([0.001, 1.0, 1.0, 0.001], [0.3, 0.4, 0.3], \cf4 \\sine\cf0 , 2, 1), gate);\
		sig = \cf2 Warp1\cf0 .ar(1, buf, ptr, frq, wsz, -1, dns, ratio) * env;\
		#rL, rR = \cf2 GVerb\cf0 .ar(sig, 20, rtime, drylevel: 0) * rev;\
		\cf2 Out\cf0 .ar(out, \cf2 PanB2\cf0 .ar(sig, azm) + \cf2 BiPanB2\cf0 .ar(rL, rR, azm))\
	\}).add;\
	\
	\cf2 SynthDef\cf0 (\cf4 \\decoder\cf0 , \{\cf2 |in|\cf0 \
		\cf2 var\cf0  w, x, y, a, b, c, d;\
		#w, x, y = \cf2 In\cf0 .ar(in, 3);\
\cf5 //		#a, b, c, d = DecodeB2.ar(4, w, x, y);\cf0 \
		\cf2 Out\cf0 .ar(0, \cf2 DecodeB2\cf0 .ar(4, w, x, y))\
	\}).add;\
	\
	~map = (\
		\cf4 \\ptr\cf0 : \cf2 ControlSpec\cf0 (0.0, 1.0),\
		\cf4 \\amp\cf0 : \cf2 ControlSpec\cf0 (1.0, 0.01),\
		\cf4 \\frq\cf0 : \cf2 ControlSpec\cf0 (35/36, 36/35),\
		\cf4 \\wsz\cf0 : \cf2 ControlSpec\cf0 (0.8, 1.2),\
		\cf4 \\dns\cf0 : \cf2 ControlSpec\cf0 (0.8, 1.2),\
		\cf4 \\azm\cf0 : \cf2 ControlSpec\cf0 (-pi, pi),\
		\cf4 \\rev\cf0 : \cf2 ControlSpec\cf0 (0.01, 0.1),\
		\cf4 \\rtime\cf0 : \cf2 ControlSpec\cf0 (2, 15)\
	);\
			\
	~statesFunc = \{\cf2 |values|\cf0 \
		values.states.clump(8).do(\{\cf2 |states, i|\cf0 \
			\cf2 var\cf0  ind = -1, args;\
			args = ~map.collect(\{\cf2 |spec|\cf0  ind=ind+1; spec.map(states[ind]) \});\
			args.frq = args.frq * ~frq[i];\
			args.wsz = args.wsz * ~wsz[i];\
			args.dns = args.dns * ~dns[i];\
			~synths[i].set( *args.asKeyValuePairs );\
		\})\
	\};\
	\
)\
\
(\
	~abus = \cf2 Bus\cf0 .audio(s, 3);\
	~sgrp = \cf2 Group\cf0 ();\
	~decoder = \cf2 Synth\cf0 .after(~sgrp, \cf4 \\decoder\cf0 , [\cf4 \\in\cf0 , ~abus]);\
	\
	~frq = \cf2 Array\cf0 .geom(8, 0.25, 2**(1/3));\
	~dns = \cf2 Array\cf0 .geom(8, 2, 2**(1/4));\
	~wsz = \cf2 Array\cf0 .geom(8, 0.1, 2**(1/5));\
	\
	~synths = \cf2 Array\cf0 .newClear(8);\
	\
	~fx.addStatesFunction(\cf4 \\states\cf0 , ~statesFunc);\
	\
	8.do(\{\cf2 |i|\cf0 \
		~synths.put(i, \
			\cf2 Synth\cf0 .tail(~sgrp, \cf4 \\fxwarp\cf0 , [\cf4 \\out\cf0 , ~abus, \cf4 \\buf\cf0 , ~buf, \cf4 \\ptr\cf0 , 0, \cf4 \\frq\cf0 , ~frq[i], \
				\cf4 \\wsz\cf0 , ~wsz[i], \cf4 \\dns\cf0 , ~dns[i], \cf4 \\ratio\cf0 , rrand(0.0, 0.01), \cf4 \\amp\cf0 , 0.7, \cf4 \\rtime\cf0 , 4, \
				\cf4 \\gate\cf0 , 1, \cf4 \\azm\cf0 , rrand(-pi, pi), \cf4 \\rev\cf0 , 0.05\
			])\
		);\
	\})\
)\
\
~fx.removeStatesFunction(\cf4 \\states\cf0 );\
~synths.do(\cf2 _\cf0 .set(\cf4 \\gate\cf0 , -5))\
\
}